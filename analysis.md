# Malware Analysis
hi
## Extracting the Source Code
The file hash of the malicious document is `340795d1f2c2bdab1f2382188a7b5c838e0a79d3f059d2db9eb274b0205f6981`. I used [oletools](https://github.com/decalage2/oletools) to extract the VBA source code from the macro.

## Layer 1
The author of the script uses a lot of newline spacing to spread apart its contents. There is a function `ParsingA()` that appears to download content from the Internet, but it never seems to be used. You'll also notice that the author uses gratuitous string concatenation to confuse readers. For instance...

```
strComputer = "."
Set objWMIService = GetObject("w" & "" & "in" & "" & "mgm" & "" & "ts" & "" & ":" & "" & "\\" & strComputer & "\r" & "" & "oot\c" & "" & "imv" & "" & "2")
```
...evaluates to the same thing as this: `Set objWMIService = GetObject("winmgmts:\\.\root\cimv2")`

Also notice the large Base64 blob that `lStr` contains. The script decodes this blob and decompresses it for execution.

### Unraveling the Base64
Below is the Python3 script I use to decode the Base64 blob mentioned earlier.

```
import base64
import sys

ifile = open(sys.argv[1], "r")
ofile = open(sys.argv[2], "w")

encoded = ""

for line in ifile:
	encoded += line

ofile.write(base64.b64decode(encoded))
```
After decoding, you'll notice that the resulting contents are still unreadable because they are gzipped. Decompress the contents using `gunzip` and you'll see an obfuscated powershell script with strange variable names meant to confuse readers. After cleaning up this mess through refactoring the code, there are many interesting things to note about malware persistence.

The script uses various methods to keep the encoded third layer payload running on the victim machine regularly.

## Layer 2

### Storing the Payload
If the victim has Powershell 3.0 or later, the script stores the encoded layer 3 payload inside `kernel32.dll`. Otherwise, the script adds a new property called `Path` to a key in the registry to store the payload. If the user has Administrator permissions, the payload will be stored in `HKLM:Software\Microsoft\Windows\CurrentVersion`. Otherwise, it will be stored in `HKCU:Software\Microsoft\Windows`.

### Non-Admins: Registry Keys
The script creates a file called `kernel32.vbs` and writes to it instructions to retrieve and execute the payload.

The attacker modifies Run registry keys to cause `kernel.vbs` to run after waiting 30 minutes each time a user logs on. If the user has administrator permissions, the targeted key is `HKLM:Software\Microsoft\Windows\CurrentVersion\Run\`. Otherwise, the targeted key is `HKCU:Software\Microsoft\Windows\CurrentVersion\Run\`.

### Admins: Creation of a New WMI Object
If the user has administrator permissions, the script creates a permanent WMI event subscription that watches for a user logon, waits 30 minutes, then executes the layer 3 payload. At this point, the program has exhibited enough strange behavior for the SentinelAgent to identify it as malware.

### Scheduled Task
The script also creates a scheduled task to run the malware 30 minutes after a user logs on. The method used to start the malware differs only slightly depending on if the user has administrator permissions. If the user is a non-admin, `wscript` is used to execute the contents of `kernel32.vbs`. Otherwise, a Invoke-Expression (IEX) cmdlet is used.

## Layer 3
Now that we've discussed the various ways the attacker achieves persistence of the malware, lets find out what the layer 3 payload is responsible for. You'll notice yet another Base64 blob inside layer 2.

You'll notice an attempt to thwart static analysis at the creation of a mutex inside the function `logic`, named `"SourceFireSux"`, a jab aimed at the security company. It may seem that the function exits prompty, but the boolean variable is set to `True` after the [construction of the mutex](https://msdn.microsoft.com/en-us/library/bwe34f1k(v=vs.110).aspx).

```
[bool]$var = $false;
$mutex = New-Object System.Threading.Mutex($true, “SourceFireSux”, [ref] $var);        
if (!$var)
{
  exit;
}
```

After decoding and deobfuscating, it is apparent that the code is repeatedly querying for DNS text records. Responses from these queries dictate behavior of the program: whether it should sleep, continue, or stop running. A result of `"idle"` would cause the process to sleep between 3500 and 5400 seconds before continuing. A result of `"stop"` would prompt the process to exit.

I suspect that the purpose of these text record queries is to retrieve yet another payload layer. Unfortunately, since these domains are not active, there is no way for us to go further. However, analysis on this script has been done [here](https://blog.talosintelligence.com/2017/03/dnsmessenger.html).\

## Layer 4
Thanks to Talos, we know what the fourth layer playload looks like.

![image](https://2.bp.blogspot.com/-S3hr64DjZCE/WLhNpISvZQI/AAAAAAAAAPA/QyjkYq1h83IpdAXhEkjDhb22s05h7LGWQCLcB/s1600/image15.png)

The `dec` function in layer 3 is used to decode this Base64 string and the result is passed to the Invoke-Expression cmdlet. According to Talos's analysis, the script redirects STDIN, STDOUT, and STDERR so the attacker can read from and write to the command line processor. The payload performs more DNS lookups and establishes a communication channel with a command and control server. From here, the attacker may send commands to be executed on the victim machine's command line interpreter and receive the results of those commands, all through DNS txt queries and responses.
